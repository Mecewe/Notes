## 字节顺序与大小端问题

什么是大端和小端

Big-Endian和Little-Endian的定义如下：

1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：

**1)大端模式：**

低地址 -----------------> 高地址

0x12  |  0x34  |  0x56  |  0x78

**2)小端模式：**

低地址 ------------------> 高地址

0x78  |  0x56  |  0x34  |  0x12

可见，大端模式和字符串的存储模式类似。

**3)下面是两个具体例子：**

16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| -------- | ---------------- | ---------------- |
| 0x4000   | 0x34             | 0x12             |
| 0x4001   | 0x12             | 0x34             |

32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：

| 内存地址 | 小端模式存放内容 | 大端模式存放内容 |
| -------- | ---------------- | ---------------- |
| 0x4000   | 0x78             | 0x12             |
| 0x4001   | 0x56             | 0x34             |
| 0x4002   | 0x34             | 0x56             |
| 0x4003   | 0x12             | 0x78             |

 **4)大端小端没有谁优谁劣，各自优势便是对方劣势：**

小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。

大端模式 ：符号位的判定固定为第一个字节，容易判断正负。

数组在大端小端情况下的存储：

以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：

Big-Endian: 低地址存放高位，如下：

高地址

\---------------

buf[3] (0x78) -- 低位

buf[2] (0x56)

buf[1] (0x34)

buf[0] (0x12) -- 高位

\---------------

低地址

Little-Endian: 低地址存放低位，如下：

高地址

\---------------

buf[3] (0x12) -- 高位

buf[2] (0x34)

buf[1] (0x56)

buf[0] (0x78) -- 低位

\--------------

低地址

为什么会有大小端模式之分呢？

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。

**\我们常用的X86结构是小端模式,网络字节顺序采用大端模式,**

如何检测大小端:

联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：

*#include * *#include * union word{ **int** a; char b;} c; **int** checkCPU(void){ c.a = 1; **printf**("c.b=%dn",c.b); **return** (c.b==1);} **int** main(void){ **int** i; i= checkCPU(); **if**(i==0) **printf**("this is Big_endiann"); **else** **if**(i==1) **printf**("this is Little_endiann"); **return** 0;}

如在小端的时候,c.b为1,大端的时候为0.

字节顺序转换函数

既然网络上传输的数据以及各种类型的主机字节顺序有差异,因此X86平台下编译网络程序的时候,要注意大小端转换.比如在绑定socket和ip地址的时候之一使用网络顺序.

htons()

ntohl()

ntohs()

函数可以实现字节顺序与主机字节顺序转换.

具体函数的使用使用的搜搜用法就好了.